'use client';

import { Canvas } from '@react-three/fiber';
import { OrbitControls, Box, Sphere, Line } from '@react-three/drei';
import { memo, useEffect, useRef, useState } from 'react';
import { useInView } from 'react-intersection-observer';
import * as THREE from 'three';

/**
 * REST API visualization (left side)
 */
function RESTVisualization({ active }: { active: boolean }) {
  const groupRef = useRef<THREE.Group>(null);

  useEffect(() => {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (groupRef.current && active) {
        groupRef.current.rotation.y += 0.005;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, [active]);

  // Multiple endpoints
  const endpoints = [
    { pos: [-4, 2, 0] as [number, number, number], color: '#3b82f6' },
    { pos: [-4, 0.5, 0] as [number, number, number], color: '#8b5cf6' },
    { pos: [-4, -1, 0] as [number, number, number], color: '#ec4899' },
    { pos: [-4, -2.5, 0] as [number, number, number], color: '#f59e0b' }
  ];

  return (
    <group ref={groupRef}>
      {/* Client */}
      <Sphere position={[-7, 0.5, 0]} args={[0.4, 32, 32]}>
        <meshStandardMaterial color="#10b981" />
      </Sphere>

      {/* Multiple REST endpoints */}
      {endpoints.map((endpoint, idx) => (
        <group key={idx}>
          <Box position={endpoint.pos} args={[0.6, 0.6, 0.6]}>
            <meshStandardMaterial
              color={endpoint.color}
              emissive={active ? endpoint.color : '#000'}
              emissiveIntensity={active ? 0.3 : 0}
            />
          </Box>
          <Line
            points={[
              new THREE.Vector3(-7, 0.5, 0),
              new THREE.Vector3(...endpoint.pos)
            ]}
            color={active ? '#60a5fa' : '#4b5563'}
            lineWidth={2}
            dashed
            dashSize={0.1}
            gapSize={0.05}
          />
        </group>
      ))}
    </group>
  );
}

/**
 * GraphQL API visualization (right side)
 */
function GraphQLVisualization({ active }: { active: boolean }) {
  const groupRef = useRef<THREE.Group>(null);

  useEffect(() => {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (groupRef.current && active) {
        groupRef.current.rotation.y -= 0.005;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, [active]);

  return (
    <group ref={groupRef}>
      {/* Client */}
      <Sphere position={[7, 0.5, 0]} args={[0.4, 32, 32]}>
        <meshStandardMaterial color="#10b981" />
      </Sphere>

      {/* Single GraphQL endpoint */}
      <Box position={[4, 0.5, 0]} args={[1, 1, 1]}>
        <meshStandardMaterial
          color="#e535ab"
          emissive={active ? '#e535ab' : '#000'}
          emissiveIntensity={active ? 0.4 : 0}
          metalness={0.5}
          roughness={0.2}
        />
      </Box>

      {/* Single connection */}
      <Line
        points={[
          new THREE.Vector3(7, 0.5, 0),
          new THREE.Vector3(4, 0.5, 0)
        ]}
        color={active ? '#a78bfa' : '#4b5563'}
        lineWidth={3}
      />

      {/* Data nodes behind endpoint (showing flexible queries) */}
      {[
        { pos: [2, 1.5, -1] as [number, number, number], color: '#3b82f6' },
        { pos: [2, 0.5, -1] as [number, number, number], color: '#8b5cf6' },
        { pos: [2, -0.5, -1] as [number, number, number], color: '#ec4899' }
      ].map((node, idx) => (
        <Sphere key={idx} position={node.pos} args={[0.25, 16, 16]}>
          <meshStandardMaterial
            color={node.color}
            transparent
            opacity={active ? 0.7 : 0.3}
          />
        </Sphere>
      ))}
    </group>
  );
}

/**
 * Comparison indicators
 */
function ComparisonLabels() {
  return (
    <>
      {/* VS separator */}
      <Sphere position={[0, 0.5, 0]} args={[0.3, 16, 16]}>
        <meshStandardMaterial color="#fbbf24" emissive="#fbbf24" emissiveIntensity={0.5} />
      </Sphere>
    </>
  );
}

/**
 * Main scene content
 */
const SceneContent = memo(function SceneContent({ showREST }: { showREST: boolean }) {
  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} intensity={1} />
      <spotLight position={[-10, 10, 5]} angle={0.3} penumbra={1} intensity={0.5} />

      <RESTVisualization active={showREST} />
      <GraphQLVisualization active={!showREST} />
      <ComparisonLabels />

      <OrbitControls
        enableZoom={true}
        enablePan={false}
        maxPolarAngle={Math.PI / 1.5}
        minPolarAngle={Math.PI / 3}
        autoRotate={false}
      />
    </>
  );
});

/**
 * Fallback content
 */
function FallbackContent() {
  return (
    <div className="flex h-full w-full items-center justify-center bg-gradient-to-br from-blue-50 to-pink-50 dark:from-blue-950 dark:to-pink-950">
      <div className="grid grid-cols-2 gap-8 px-4 max-w-4xl">
        <div className="text-center">
          <div className="text-5xl mb-3">ðŸ”—</div>
          <h3 className="text-lg font-bold text-gray-900 dark:text-white mb-3">REST API</h3>
          <div className="space-y-2 text-sm">
            <div className="bg-blue-100 dark:bg-blue-900/30 p-2 rounded">
              Multiple endpoints
            </div>
            <div className="bg-purple-100 dark:bg-purple-900/30 p-2 rounded">
              Fixed data structures
            </div>
            <div className="bg-orange-100 dark:bg-orange-900/30 p-2 rounded">
              Over/under-fetching
            </div>
          </div>
        </div>

        <div className="text-center">
          <div className="text-5xl mb-3">âš¡</div>
          <h3 className="text-lg font-bold text-gray-900 dark:text-white mb-3">GraphQL</h3>
          <div className="space-y-2 text-sm">
            <div className="bg-pink-100 dark:bg-pink-900/30 p-2 rounded">
              Single endpoint
            </div>
            <div className="bg-purple-100 dark:bg-purple-900/30 p-2 rounded">
              Flexible queries
            </div>
            <div className="bg-green-100 dark:bg-green-900/30 p-2 rounded">
              Precise data fetching
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

/**
 * RESTvsGraphQLScene: Side-by-side API comparison
 *
 * Features:
 * - Visual comparison of request patterns
 * - Alternating animations
 * - Over-fetching demonstration
 * - Performance optimized
 */
export default function RESTvsGraphQLScene() {
  const { ref, inView } = useInView({
    triggerOnce: true,
    threshold: 0.1,
    rootMargin: '200px'
  });

  const [hasWebGL, setHasWebGL] = useState(true);
  const [isLoaded, setIsLoaded] = useState(false);
  const [showREST, setShowREST] = useState(true);

  useEffect(() => {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    setHasWebGL(!!gl);
    setIsLoaded(true);
  }, []);

  // Alternate between REST and GraphQL
  useEffect(() => {
    if (!inView || !hasWebGL) return;

    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) return;

    const interval = setInterval(() => {
      setShowREST(prev => !prev);
    }, 3000);

    return () => clearInterval(interval);
  }, [inView, hasWebGL]);

  if (!isLoaded) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden flex items-center justify-center bg-gray-50 dark:bg-gray-800">
        <div className="animate-pulse text-gray-500">Loading...</div>
      </div>
    );
  }

  if (!hasWebGL) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
        <FallbackContent />
      </div>
    );
  }

  return (
    <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
      {inView && (
        <Canvas
          camera={{ position: [0, 2, 12], fov: 50 }}
          gl={{ antialias: true, alpha: true, powerPreference: 'high-performance' }}
          dpr={Math.min(window.devicePixelRatio, 2)}
        >
          <color attach="background" args={['#0f172a']} />
          <fog attach="fog" args={['#0f172a', 10, 20]} />
          <SceneContent showREST={showREST} />
        </Canvas>
      )}
    </div>
  );
}
