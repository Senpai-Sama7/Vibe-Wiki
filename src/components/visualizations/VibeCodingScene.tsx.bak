'use client';

import { Canvas } from '@react-three/fiber';
import { OrbitControls, Sphere, Box, Torus, Line } from '@react-three/drei';
import { memo, useEffect, useRef, useState } from 'react';
import { useInView } from 'react-intersection-observer';
import * as THREE from 'three';

interface VibeCodingSceneProps {
  showWorkflow?: boolean;
  animateSteps?: boolean;
  animation?: {
    duration: number;
    easing: string;
  };
}

/**
 * Animated workflow nodes
 */
function WorkflowNode({ position, color, type }: { position: [number, number, number]; color: string; type: 'human' | 'ai' | 'code' }) {
  const meshRef = useRef<THREE.Mesh>(null);

  useEffect(() => {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (meshRef.current) {
        meshRef.current.rotation.x += 0.01;
        meshRef.current.rotation.y += 0.01;
        if (type === 'human') {
          meshRef.current.position.y = position[1] + Math.sin(Date.now() * 0.001) * 0.2;
        }
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, [position, type]);

  return (
    <group position={position}>
      {type === 'human' && (
        <Sphere ref={meshRef} args={[0.5, 32, 32]}>
          <meshStandardMaterial color={color} metalness={0.3} roughness={0.4} />
        </Sphere>
      )}
      {type === 'ai' && (
        <Box ref={meshRef} args={[1, 1, 1]}>
          <meshStandardMaterial color={color} emissive={color} emissiveIntensity={0.2} metalness={0.5} roughness={0.3} />
        </Box>
      )}
      {type === 'code' && (
        <Torus ref={meshRef} args={[0.5, 0.2, 16, 32]}>
          <meshStandardMaterial color={color} metalness={0.4} roughness={0.3} />
        </Torus>
      )}
    </group>
  );
}

/**
 * Connection lines between workflow nodes
 */
function WorkflowConnections() {
  const points1 = [new THREE.Vector3(-3, 0, 0), new THREE.Vector3(0, 0, 0)];
  const points2 = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(3, 0, 0)];

  return (
    <>
      <Line points={points1} color="#60a5fa" lineWidth={2} />
      <Line points={points2} color="#60a5fa" lineWidth={2} />
    </>
  );
}

/**
 * Floating particles background
 */
function Particles() {
  const particlesRef = useRef<THREE.Points>(null);

  useEffect(() => {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (particlesRef.current) {
        particlesRef.current.rotation.y += 0.0005;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, []);

  const particlePositions = new Float32Array(300);
  for (let i = 0; i < 100; i++) {
    particlePositions[i * 3] = (Math.random() - 0.5) * 20;
    particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 20;
    particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 20;
  }

  return (
    <points ref={particlesRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={100}
          array={particlePositions}
          itemSize={3}
        />
      </bufferGeometry>
      <pointsMaterial size={0.05} color="#6366f1" transparent opacity={0.6} />
    </points>
  );
}

/**
 * Main Three.js scene content
 */
const SceneContent = memo(function SceneContent() {
  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} intensity={1} />
      <spotLight position={[-10, 10, 5]} angle={0.3} penumbra={1} intensity={0.5} />

      <WorkflowNode position={[-3, 0, 0]} color="#3b82f6" type="human" />
      <WorkflowNode position={[0, 0, 0]} color="#8b5cf6" type="ai" />
      <WorkflowNode position={[3, 0, 0]} color="#10b981" type="code" />
      <WorkflowConnections />
      <Particles />

      <OrbitControls
        enableZoom={false}
        enablePan={false}
        maxPolarAngle={Math.PI / 2}
        minPolarAngle={Math.PI / 2}
        autoRotate
        autoRotateSpeed={0.5}
      />
    </>
  );
});

/**
 * WebGL fallback content
 */
function FallbackContent() {
  return (
    <div className="flex h-full w-full items-center justify-center bg-gradient-to-br from-blue-50 to-purple-50 dark:from-blue-950 dark:to-purple-950">
      <div className="text-center px-4">
        <div className="text-6xl mb-4">ðŸš€</div>
        <h3 className="text-xl font-bold text-gray-900 dark:text-white mb-2">
          Vibe Coding Workflow
        </h3>
        <p className="text-gray-600 dark:text-gray-400 max-w-md">
          Developer describes requirements â†’ AI generates code â†’ Developer refines
        </p>
      </div>
    </div>
  );
}

/**
 * VibeCodingScene: 3D visualization of the vibe coding workflow
 *
 * Performance optimizations:
 * - Intersection Observer for lazy loading
 * - React.memo for expensive renders
 * - Proper cleanup on unmount
 * - Reduced-motion support
 * - WebGL fallback
 */
export default function VibeCodingScene({
  showWorkflow = true,
}: VibeCodingSceneProps) {
  const { ref, inView } = useInView({
    triggerOnce: true,
    threshold: 0.1,
    rootMargin: '200px'
  });

  const [hasWebGL, setHasWebGL] = useState(true);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    // Check WebGL support
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    setHasWebGL(!!gl);
    setIsLoaded(true);
  }, []);

  if (!isLoaded) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden flex items-center justify-center bg-gray-50 dark:bg-gray-800">
        <div className="animate-pulse text-gray-500">Loading...</div>
      </div>
    );
  }

  if (!hasWebGL || !showWorkflow) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
        <FallbackContent />
      </div>
    );
  }

  return (
    <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
      {inView && (
        <Canvas
          camera={{ position: [0, 0, 8], fov: 50 }}
          gl={{ antialias: true, alpha: true, powerPreference: 'high-performance' }}
          dpr={Math.min(window.devicePixelRatio, 2)}
        >
          <color attach="background" args={['#0f172a']} />
          <fog attach="fog" args={['#0f172a', 5, 15]} />
          <SceneContent />
        </Canvas>
      )}
    </div>
  );
}
