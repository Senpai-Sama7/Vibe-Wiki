'use client';

import { Canvas } from '@react-three/fiber';
import { OrbitControls, Box, Sphere, Line } from '@react-three/drei';
import { memo, useEffect, useRef, useState } from 'react';
import { useInView } from 'react-intersection-observer';
import * as THREE from 'three';

/**
 * Server component representation
 */
function ServerComponent({ position }: { position: [number, number, number] }) {
  const meshRef = useRef<THREE.Mesh>(null);

  useEffect(() => {
    const prefersReducedMotion = typeof window !== 'undefined'
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (meshRef.current) {
        meshRef.current.rotation.y += 0.01;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, []);

  return (
    <Box ref={meshRef} position={position} args={[1.2, 1.2, 1.2]}>
      <meshStandardMaterial color="#3b82f6" metalness={0.5} roughness={0.3} />
    </Box>
  );
}

/**
 * Client component representation
 */
function ClientComponent({ position }: { position: [number, number, number] }) {
  const meshRef = useRef<THREE.Mesh>(null);

  useEffect(() => {
    const prefersReducedMotion = typeof window !== 'undefined'
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (meshRef.current) {
        meshRef.current.rotation.x += 0.008;
        meshRef.current.rotation.z += 0.008;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, []);

  return (
    <Box ref={meshRef} position={position} args={[1, 1, 1]}>
      <meshStandardMaterial color="#8b5cf6" metalness={0.4} roughness={0.4} />
    </Box>
  );
}

/**
 * Data streaming particles
 */
function DataStream({ from, to }: { from: [number, number, number]; to: [number, number, number] }) {
  const particlesRef = useRef<THREE.Points>(null);

  useEffect(() => {
    const prefersReducedMotion = typeof window !== 'undefined'
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    let offset = 0;

    const animate = () => {
      if (particlesRef.current) {
        offset += 0.01;
        const positions = particlesRef.current.geometry.attributes.position.array as Float32Array;

        for (let i = 0; i < positions.length; i += 3) {
          const t = ((i / 3) / 10 + offset) % 1;
          positions[i] = from[0] + (to[0] - from[0]) * t;
          positions[i + 1] = from[1] + (to[1] - from[1]) * t;
          positions[i + 2] = from[2] + (to[2] - from[2]) * t;
        }

        particlesRef.current.geometry.attributes.position.needsUpdate = true;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, [from, to]);

  const particleCount = 10;
  const positions = new Float32Array(particleCount * 3);

  for (let i = 0; i < particleCount; i++) {
    const t = i / particleCount;
    positions[i * 3] = from[0] + (to[0] - from[0]) * t;
    positions[i * 3 + 1] = from[1] + (to[1] - from[1]) * t;
    positions[i * 3 + 2] = from[2] + (to[2] - from[2]) * t;
  }

  return (
    <points ref={particlesRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={particleCount}
          array={positions}
          itemSize={3}
        />
      </bufferGeometry>
      <pointsMaterial size={0.1} color="#10b981" transparent opacity={0.8} />
    </points>
  );
}

/**
 * Boundary line between server and client
 */
function BoundaryLine() {
  const points = [
    new THREE.Vector3(-4, 0, -2),
    new THREE.Vector3(-4, 0, 2),
    new THREE.Vector3(-4, 3, 2),
    new THREE.Vector3(-4, 3, -2),
    new THREE.Vector3(-4, 0, -2)
  ];

  return (
    <Line
      points={points}
      color="#fbbf24"
      lineWidth={3}
      dashed
      dashSize={0.2}
      gapSize={0.1}
    />
  );
}

/**
 * Component tree structure
 */
function ComponentTree() {
  return (
    <>
      {/* Server-side components */}
      <ServerComponent position={[-6, 2, 0]} />
      <ServerComponent position={[-6, 0, -1.5]} />
      <ServerComponent position={[-6, 0, 1.5]} />

      {/* Client-side components */}
      <ClientComponent position={[-2, 2, 0]} />
      <ClientComponent position={[-2, 0, -1.5]} />
      <ClientComponent position={[-2, 0, 1.5]} />

      {/* Browser components */}
      <Sphere position={[2, 1, 0]} args={[0.6, 32, 32]}>
        <meshStandardMaterial color="#ec4899" metalness={0.5} roughness={0.3} />
      </Sphere>

      {/* Data streams */}
      <DataStream from={[-6, 2, 0]} to={[-2, 2, 0]} />
      <DataStream from={[-6, 0, -1.5]} to={[-2, 0, -1.5]} />
      <DataStream from={[-6, 0, 1.5]} to={[-2, 0, 1.5]} />
      <DataStream from={[-2, 2, 0]} to={[2, 1, 0]} />

      {/* Connection lines */}
      <Line
        points={[new THREE.Vector3(-6, 2, 0), new THREE.Vector3(-2, 2, 0)]}
        color="#60a5fa"
        lineWidth={1}
      />
      <Line
        points={[new THREE.Vector3(-2, 2, 0), new THREE.Vector3(2, 1, 0)]}
        color="#a78bfa"
        lineWidth={1}
      />
    </>
  );
}

/**
 * Main scene content
 */
const SceneContent = memo(function SceneContent() {
  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} intensity={1} />
      <spotLight position={[-10, 10, 5]} angle={0.3} penumbra={1} intensity={0.5} />

      <ComponentTree />
      <BoundaryLine />

      <OrbitControls
        enableZoom={true}
        enablePan={false}
        maxPolarAngle={Math.PI / 1.5}
        minPolarAngle={Math.PI / 3}
        autoRotate={false}
      />
    </>
  );
});

/**
 * Fallback content
 */
function FallbackContent() {
  return (
    <div className="flex h-full w-full items-center justify-center bg-gradient-to-br from-blue-50 to-purple-50 dark:from-blue-950 dark:to-purple-950">
      <div className="text-center px-4">
        <div className="text-6xl mb-4">âš¡</div>
        <h3 className="text-xl font-bold text-gray-900 dark:text-white mb-4">
          Server vs Client Components
        </h3>
        <div className="space-y-3 text-left max-w-md">
          <div className="bg-blue-100 dark:bg-blue-900/30 p-3 rounded">
            <span className="font-semibold">Server:</span> Runs on server, data fetching, DB access
          </div>
          <div className="bg-purple-100 dark:bg-purple-900/30 p-3 rounded">
            <span className="font-semibold">Client:</span> Interactive, hooks, browser APIs
          </div>
          <div className="bg-green-100 dark:bg-green-900/30 p-3 rounded">
            <span className="font-semibold">Streaming:</span> Progressive HTML rendering
          </div>
        </div>
      </div>
    </div>
  );
}

/**
 * ServerClientFlow: React Server Components visualization
 *
 * Features:
 * - Server and client component boundaries
 * - Data streaming animation
 * - Component tree structure
 * - Performance optimized
 */
export default function ServerClientFlow() {
  const { ref, inView } = useInView({
    triggerOnce: true,
    threshold: 0.1,
    rootMargin: '200px'
  });

  const [hasWebGL, setHasWebGL] = useState(true);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    setHasWebGL(!!gl);
    setIsLoaded(true);
  }, []);

  if (!isLoaded) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden flex items-center justify-center bg-gray-50 dark:bg-gray-800">
        <div className="animate-pulse text-gray-500">Loading...</div>
      </div>
    );
  }

  if (!hasWebGL) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
        <FallbackContent />
      </div>
    );
  }

  return (
    <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
      {inView && (
        <Canvas
          camera={{ position: [0, 2, 10], fov: 50 }}
          gl={{ antialias: true, alpha: true, powerPreference: 'high-performance' }}
          dpr={Math.min(window.devicePixelRatio, 2)}
        >
          <color attach="background" args={['#0f172a']} />
          <fog attach="fog" args={['#0f172a', 8, 20]} />
          <SceneContent />
        </Canvas>
      )}
    </div>
  );
}
