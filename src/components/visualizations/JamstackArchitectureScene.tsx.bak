'use client';

import { Canvas } from '@react-three/fiber';
import { OrbitControls, Cylinder, Sphere } from '@react-three/drei';
import { memo, useEffect, useRef, useState } from 'react';
import { useInView } from 'react-intersection-observer';
import * as THREE from 'three';

/**
 * Individual JAMstack layer
 */
function StackLayer({ position, radius, color }: {
  position: [number, number, number];
  radius: number;
  color: string;
}) {
  const meshRef = useRef<THREE.Mesh>(null);

  useEffect(() => {
    const prefersReducedMotion = typeof window !== 'undefined'
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const baseY = position[1];
    const animate = () => {
      if (meshRef.current) {
        meshRef.current.position.y = baseY + Math.sin(Date.now() * 0.002 + baseY) * 0.1;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, [position]);

  return (
    <group position={position}>
      <Cylinder ref={meshRef} args={[radius, radius, 0.3, 32]}>
        <meshStandardMaterial color={color} metalness={0.3} roughness={0.4} />
      </Cylinder>
    </group>
  );
}

/**
 * CDN nodes orbiting the stack
 */
function CDNNodes() {
  const groupRef = useRef<THREE.Group>(null);

  useEffect(() => {
    const prefersReducedMotion = typeof window !== 'undefined'
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (groupRef.current) {
        groupRef.current.rotation.y += 0.001;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, []);

  const cdnCount = 8;
  const radius = 2.5;
  const nodes = Array.from({ length: cdnCount }, (_, i) => {
    const angle = (i / cdnCount) * Math.PI * 2;
    return {
      position: [
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
      ] as [number, number, number],
      key: i
    };
  });

  return (
    <group ref={groupRef}>
      {nodes.map(({ position, key }) => (
        <Sphere key={key} position={position} args={[0.15, 16, 16]}>
          <meshStandardMaterial
            color="#10b981"
            emissive="#10b981"
            emissiveIntensity={0.3}
          />
        </Sphere>
      ))}
    </group>
  );
}

/**
 * Main scene content
 */
const SceneContent = memo(function SceneContent() {
  const groupRef = useRef<THREE.Group>(null);

  useEffect(() => {
    const prefersReducedMotion = typeof window !== 'undefined'
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;
    if (prefersReducedMotion) return;

    let animationFrameId: number;
    const animate = () => {
      if (groupRef.current) {
        groupRef.current.rotation.y += 0.001;
      }
      animationFrameId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationFrameId);
  }, []);

  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} intensity={1} />
      <spotLight position={[-10, 10, 5]} angle={0.3} penumbra={1} intensity={0.5} />

      <group ref={groupRef}>
        {/* JavaScript/Frontend Layer (bottom) */}
        <StackLayer position={[0, -1, 0]} radius={1.5} color="#f7df1e" label="Frontend (JS)" />

        {/* API Layer (middle) */}
        <StackLayer position={[0, 0, 0]} radius={1.3} color="#00d8ff" label="APIs" />

        {/* Markup Layer (top) */}
        <StackLayer position={[0, 1, 0]} radius={1.1} color="#e34c26" label="Markup" />

        {/* CDN Nodes */}
        <CDNNodes />
      </group>

      <OrbitControls
        enableZoom={true}
        enablePan={false}
        maxPolarAngle={Math.PI / 1.5}
        minPolarAngle={Math.PI / 3}
        autoRotate={false}
      />
    </>
  );
});

/**
 * Fallback content for non-WebGL browsers
 */
function FallbackContent() {
  return (
    <div className="flex h-full w-full items-center justify-center bg-gradient-to-br from-yellow-50 to-orange-50 dark:from-yellow-950 dark:to-orange-950">
      <div className="text-center px-4">
        <div className="text-6xl mb-4">üèóÔ∏è</div>
        <h3 className="text-xl font-bold text-gray-900 dark:text-white mb-4">
          JAMstack Architecture
        </h3>
        <div className="space-y-2 text-left max-w-md">
          <div className="bg-red-100 dark:bg-red-900/30 p-3 rounded">
            <span className="font-semibold">Markup:</span> Pre-built HTML
          </div>
          <div className="bg-blue-100 dark:bg-blue-900/30 p-3 rounded">
            <span className="font-semibold">APIs:</span> Serverless functions
          </div>
          <div className="bg-yellow-100 dark:bg-yellow-900/30 p-3 rounded">
            <span className="font-semibold">JavaScript:</span> Dynamic features
          </div>
          <div className="bg-green-100 dark:bg-green-900/30 p-3 rounded">
            <span className="font-semibold">CDN:</span> Global distribution
          </div>
        </div>
      </div>
    </div>
  );
}

/**
 * JamstackArchitectureScene: 3D visualization of JAMstack layers
 *
 * Features:
 * - Stacked cylinder layers representing architecture tiers
 * - Orbiting CDN nodes
 * - Interactive camera controls
 * - Performance optimized with lazy loading
 * - WebGL fallback support
 */
export default function JamstackArchitectureScene() {
  const { ref, inView } = useInView({
    triggerOnce: true,
    threshold: 0.1,
    rootMargin: '200px'
  });

  const [hasWebGL, setHasWebGL] = useState(true);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    setHasWebGL(!!gl);
    setIsLoaded(true);
  }, []);

  if (!isLoaded) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden flex items-center justify-center bg-gray-50 dark:bg-gray-800">
        <div className="animate-pulse text-gray-500">Loading...</div>
      </div>
    );
  }

  if (!hasWebGL) {
    return (
      <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
        <FallbackContent />
      </div>
    );
  }

  return (
    <div ref={ref} className="w-full h-[400px] rounded-lg overflow-hidden">
      {inView && (
        <Canvas
          camera={{ position: [4, 2, 4], fov: 50 }}
          gl={{ antialias: true, alpha: true, powerPreference: 'high-performance' }}
          dpr={Math.min(window.devicePixelRatio, 2)}
        >
          <color attach="background" args={['#0f172a']} />
          <fog attach="fog" args={['#0f172a', 5, 15]} />
          <SceneContent />
        </Canvas>
      )}
    </div>
  );
}
